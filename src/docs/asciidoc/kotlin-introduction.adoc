= Kotlin Introduction
2017-07-19
:revnumber: {project-version}
ifndef::imagesdir[:imagesdir: images]
ifndef::sourcedir[:sourcedir: ../java]

== Outline
* What is Kotlin?
* Where is it used?
* A Better Java

== What is Kotlin
* Statically typed language
* Inspired by Java, Scala, C#, Groovy amongst others
* Targets
** JVM / Android
** JavaScript
** Native


== Short History of Kotlin
* *2010* - Created
* *2016* - 1.0 Release
* *2017* - 1.1 Release, Android 1^st^ class support

== Kotlin vs. Java

Some common code patterns in Java, reimplemented in Kotlin

=== DTO / Value Objects

* A Simple class with one mutable and one immutable property

=== Java
[source,java]
-----
public class Author {
    private final String name;
    private String pseudonym;
    public Author(String name, String pseudonym) { /*...*/ }

    public String getName() { /*...*/ }
    public String getPseudonym() { /*...*/ }
    public void setPseudonym(String pseudonym) { /*...*/ }

    @Override public boolean equals(Object o) { /*...*/ }
    @Override public int hashCode() { /*...*/ }
    @Override public String toString() { /*...*/ }
}
-----

[NOTE.speaker]
--
The real class is around 50 lines long
--

=== Kotlin
[source,java]
-----
data class Author(val name: String, var pseudonym: String)
-----
[NOTE.speaker]
--
The works as a JavaBean with frameworks like Jaxon, Hibernate etc.
--

=== Builder Pattern

A way of constructing an instance of a class in different ways,
often through a fluent API.

[plantuml]
-----
@startuml
class ColourScheme *-- Car
class Propulsion *-- Car
class upholstery *-- Car
class Car {
  -colourScheme: ColourScheme
  -propulsion: Propulsion
  -upholstery: Upholstery
}
@enduml
-----


=== Java (use)
[source,java]
-----
Car defaultCar = new Car.Builder().createCar();

Car nonVeganCar = new Car.Builder()
        .withUpholstery(new Upholstery("leather"))
        .createCar();

Car customCar = new Car.Builder()
        .withColourScheme(new ColourScheme(Color.BISQUE))
        .withPropulsion(new Propulsion("diesel"))
        .withUpholstery(new Upholstery("Gold Stitched Denim"))
        .createCar();
-----

=== Kotlin (use)
[source,java]
-----
val defaultCar = Car()

val nonVeganCar = Car(upholstery = Upholstery("leather"))

val customCar = Car(
        colourScheme = ColourScheme(Color.BISQUE),
        propulsion = Propulsion("diesel"),
        upholstery = Upholstery("Gold Stitched Denim")

// Copy and customise
val betterCustomCar = customCar.copy(
            colourScheme = ColourScheme(Color.MAGENTA)
        )
)
-----

=== Java (source)
[source,java]
-----
/* Other class definitions ...*/
class Car {
  /* Fields, constructor, getters/setters ...*/
  static class Builder {
    // Defaults
    ColourScheme colourScheme = new ColourScheme(Color.BLACK);
    Propulsion propulsion = new Propulsion("electric");
    Upholstery upholstery = new Upholstery("pvc");

    Builder withColourScheme(ColourScheme colourScheme) {/*...*/}
    Builder withPropulsion(Propulsion propulsion) { /*...*/ }
    Builder withUpholstery(Upholstery upholstery) { /*...*/ }
    Car createCar() { /*...*/ }
  }
}
-----

=== Kotlin (source)
[source,java]
-----
/* Complete */
data class ColourScheme(val colour: Color)
data class Propulsion(val type: String)
data class Upholstery(val fabric: String)

// Default argument values
data class Car(
    val colourScheme: ColourScheme = ColourScheme(Color.BLACK),
    val propulsion: Propulsion = Propulsion("electric"),
    val upholstery: Upholstery = Upholstery("pvc")
)

-----

=== Collections
Java 8 streams finally introduced the filter/map/reduce
API and lambdas but didn't make them available on existing
collections.

=== Java
[source,java]
-----
List<String> colours = new ArrayList() {{
    add("Red"); add("Orange"); add("Yellow"); /**/ add("Violet");
}};

List<String> filtered = colours.stream()
        .filter((c) -> c.toLowerCase().contains("o"))
        .collect(Collectors.toList());

filtered.add("Octarine");

assert filtered.contains("Octarine");
-----

=== Kotlin
[source,java]
-----
// Easy declaration
val colours = listOf("Red", "Orange", "Yellow", /*..*/ "Violet")

// No 'stream' or 'collect'.  Default single argument 'it'
val filtered = colours.filter { it.toLowerCase().contains("o") }
// filtered.add() -- no such method

// Immutable by default
val mutable = filtered.toMutableList()
mutable.add("Octarine")

assert(mutable.contains("Octarine"))
-----

=== 'If' Expressions
* A statement is imperative
** It must have side effects to be useful
* An expression returns a result
** Side-effects are optional

=== Java
[source,java]
-----
boolean proceed = false;

if (lights == RED) proceed = false;
else if (lights == RED && lights == AMBER) proceed = true;
else  proceed = (lights == GREEN);
-----

=== Kotlin
[source,java]
-----
val proceed =
        if (lights == RED) false
        else if (lights == RED && lights == AMBER) true
        else lights == GREEN
-----
OR
[source,java]
-----
val size = when (Random().nextInt(100)) {
    in 0.. 10 -> "low"
    in 11..50 -> "medium"
    else -> "high"
}
-----
[NOTE.speaker]
--
Slightly less code, stops assignment and initialisation being accidentally split.
`when` blocks can work with many other built in predicates
--



=== Helper functions

Utility functions that don't belong to a specific class are awkward to
use in Java

* Swap from 'dot' to wrapped function call

=== Java
[source,java]
-----
boolean isPalindrome(String s) {
    return s.equalsIgnoreCase(reverse(s));
}

String reverse(String s) { /*...*/ }

List<String> words = new ArrayList() {{
    add("Anna"); add("Eye"); add("Noon"); add("Civic");
    add("Level");
}};

assert words.stream()
        .allMatch(s -> isPalindrome(s));
-----

=== Kotlin
[source,java]
-----
// Locally-scoped additions to any 'String' instance
fun String.isPalindrome(): Boolean =
        this.equals(this.reverse(), ignoreCase = true)

fun String.reverse(): String { /*...*/ }

val words = listOf("Anna", "Eye", "Noon", "Civic", "Level")

assert(words.all { it.isPalindrome() })
-----


=== Strings
Java `Strings` haven't changed much since the beginning of the language

=== Java
[source,java]
-----

String multiLine = "Windows NT crashed.\n" +
        "I am the Blue Screen of Death.\n" +
        "No one hears your screams.";

String greetingFor(LocalTime now) {
    if (now.isBefore(LocalTime.NOON)) return "Morning";
    else if (now.isBefore(LocalTime.of(18,0))) return "Afternoon";
    else return "Evening";
}

System.out.println("Good " +
        greetingFor(LocalTime.now()) + " Tony.");
-----

=== Kotlin
[source,java]
-----
val multiLine = """The Tao that is seen
Is not the true Tao, until
You bring fresh toner."""

fun LocalTime.greeting(): String = when {
    isBefore(LocalTime.NOON) -> "Morning"
    isBefore(LocalTime.of(18, 0)) -> "Afternoon"
    else -> "Evening"
}

// String interpolation
println("Good ${LocalTime.now().greeting()} Tony.")
-----

=== Java
[source,java]
-----
-----

=== Kotlin
[source,java]
-----
-----

== Questions?


== End

== A Better Java

=== Basics
[%step]
* Java / C style
* No semicolons required
* Inferred types
* No ``static`` values
* ``public`` visibility by default
* No checked Exceptions

=== Scripts

(no class/package definition)

[source,java]
-----
import java.io.File

val hosts = File("/etc/hosts").readText()
hosts.split('\n')
        .filter { !it.startsWith('#') }
        .map { it.split("""\s+""")[0] }
        .forEach { println(it) }
-----

[NOTE.speaker]
--
* Compilation overhead
* Useful for experiments
* Can be run from the REPL (``kotlinc``)
--

=== Classes

[source,java]
-----
class TelephoneLine(val number: String) {
    // ...
}
-----

[NOTE.speaker]
--
* A class with a single, immutable property set in the constructor
--

=== Data Classes

[source,java]
-----
data class User(val id: Long, val name: String,
                var lastLogin: Instant = Instant.now())
-----

[NOTE.speaker]
--
* A class with
** three properties (one mutable with a default value)
** ``equals()`` / ``hashCode()``
** ``toString()``
** ``copy()`` (``Clonable`` done right)
--

=== Null Safety

[source,java]
-----
var safe: String = "foo"
safe  = null // Compilation error

val unsafe = null // Compiles

if (unsafe.contains("o")) // Compilation error (may be null)
if (unsafe != null) {
    if (unsafe.contains("o")) { } // OK, checked
}
-----

[NOTE.speaker]
--
* Non-null values enforced *by the compiler*
* The compiler tracks if a nullable value has been checked
--

=== Casting

[source,java]
-----
val x: Any = "bang" // 'Smart' cast
x.toUpperCase() // Compilation error, no method Any#toUpperCase

if (x is String) {
    print(x.toUpperCase()) // x is automatically cast to String
}

val y = x as String // 'Unsafe' cast, may throw exception
y.toUpperCase() // Compiles
-----

[NOTE.speaker]
--
* The compiler tracks any type checks
--

=== Immutability

[source,java]
-----
val immutable = "foo" // Type-inference
immutable = "bar" // Compilation error

val things = listOf("foo", "bar", "baz")
things.remove("baz") // Compilation error
val newThings = things.minus("baz") // 'things' unchanged

val ephemeralThings = mutableListOf("foo", "bar", "baz")
ephemeralThings.remove("baz")
-----

[NOTE.speaker]
--
* Compile-time checks for immutability
--

=== `if` expressions
[source,java]
-----
val proceed =
      if (RED) false
      else if (RED && AMBER && isClear)  true
      else if (GREEN) true
      else false

-----

[NOTE.speaker]
--
* Evaluates to a value
* Must be an exhaustive check
** No need for Ternary expression (``? : ``)
--

=== `when` expressions
[source,java]
-----
val proceed = when {
    RED -> false
    (RED && AMBER && isClear) -> true
    GREEN -> true
    else -> false
}

// Can use any expression
when (x) {
    in 1..10 -> print("x is in the range")
    in validNumbers -> print("x is valid")
    !in 10..20 -> print("x is outside the range")
    else -> print("none of the above")
}
-----

[NOTE.speaker]
--
* Cleaner syntax
* Must be exhaustive when assigning
--

=== `try` expressions

=== Use `elvis` with `return` and `throw`

=== Type Aliases

=== Destructuring
[source,java]
-----
fun printMap(m: Map<String, String>) {
  for (e in m.entries) {
    println("${e.key} -> ${e.value}")
  }
}

// With destructuring
fun printMap(m: Map<String, String>) {
  for ((key, value) in m) {
    println("$key -> $value")
  }
}

-----

=== `apply` for construction
[source,java]
-----
// Construct, populate, return
fun createLabel(): JLabel {
  val label = JLabel("Foo")
  label.foreground = Color.RED
  label.background = Color.BLUE
  return label
}

// using apply
fun createLabel(): JLabel =
  JLabel("Foo").apply {
      foreground = Color.RED
      background = Color.BLUE
  }
-----
